<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Spatula by MichalKnapik</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Spatula</h1>
        <p class="header">Parametric synthesis tool for a branching action temporal logic.</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/MichalKnapik/spatula/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/MichalKnapik/spatula/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/MichalKnapik/spatula">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/MichalKnapik">MichalKnapik</a></p>


      </header>
      <section>
        <h1>
<a name="spatula-alpha" class="anchor" href="#spatula-alpha"><span class="octicon octicon-link"></span></a>SPATULA alpha</h1>

<p>SPATULA is a simple parametric synthesis tool prototype. It takes as an input a network of graphs 
(also called mixed transition systems) with labeled nodes and transitions and a parametric 
branching-action logic property to be verified. The output consists of a set of substitutions
under which the property holds. </p>

<p>In the examples/ directory you can find example models and model generators: Peterson's mutual exclusion prootocol with malicious process injected, and toy, scalable example used to measure the tool's efficiency.</p>

<h2>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>It should be easy on a recent Linux machine, just type 'make'. 
The main dependencies are induced by Fabio Somenzi's CUDD package (here, the CUDD 2.5.0 is used).</p>

<h2>
<a name="model-description-language" class="anchor" href="#model-description-language"><span class="octicon octicon-link"></span></a>Model description language</h2>

<p>The used language is a simple C-like one. A system consists of one or more independent 
modules. A module is defined using the "module" keyword, as in:</p>

<pre><code>module Single:
  i = 0;
  for i in (0..100) {
    vertex = "vertex_" + i;
    bloom(vertex);
  }
</code></pre>

<p>(The above code creates 100 vertices, named "vertex_n" where n ranges over [0, 99].
The range in for loop needs to be literal, without references.)</p>

<p>All the used variables need to be defined and initialised. There is no variable
shadowing, so once defined a variable is visible in its scope and all subscopes.
Variables can only take two types, string and integer. Arithmetic operations on 
integers are allowed; strings implement only concatenation. An integer can be added 
to string and the result is a string via concatenation. Once a variable has an 
associated value, its type can't be changed.</p>

<pre><code>module Variables:
/* valid statements */
st = "a string";
st = st + "_";  
st = st + 1001; 
in = 1234;
nst = st + in;
inval = in/0; /* causes runtime error */

/* errors */
st = 123; /* type mismatch */
in = st; /* type mismatch */
</code></pre>

<p>Core graph-building functionalities are:</p>

<pre><code>/* emerges a vertex with vertex_name */
bloom(vertex_name); 

/* labels previously emerged vertex vertex_name with proposition */
mark_with(vertex_name, proposition); 
</code></pre>

<p>Note: if you mark a vertex with "initial" label, then it will be an initial node.</p>

<pre><code>/* joins first vertex with second one (both need to be bloomed before)
and labels the transition with trans_label                          */
join_with(first, last, trans_label);
</code></pre>

<p>The language supports three types of flow control operations: while, if/else and for.
The example of "for" use is shown above. The remaining operations are as in the following
example.</p>

<pre><code>module Single:
  x = 0; max = 5;
  while(x &lt; max) {

    current = "vertex_" + x; /* current vertex name */
    bloom(current); /* make vertex */

    if(x &gt;= 1) { /* join previous and current vertex with jump label */
    previous = "vertex_" + (x - 1);
    join_with(previous, current, "jump"); 
    }

  if(x%2 == 1) /* mark vertices with labels */
    mark_with(current, "p");
  else 
    mark_with(current, "q");

  x = x + 1;    
 }       

 /* join last with first */
 first = "vertex_" + (max - 1);
 last = "vertex_" + 0;
 join_with(first, last, "return");
</code></pre>

<p>Only simple comparisons are allowed in conditions, so use double 'if' in place
of 'and', e.g.:</p>

<pre><code> if(i != 2) if(i != 3) mark_with(vec, "p");
</code></pre>

<p>For simple debugging the "stackdump" operation can be called to print the current interpreter stack.</p>

<p>If you wish to use a disjunctive semantics for parallel composition, put:</p>

<pre><code>semantics disjunctive;
</code></pre>

<p>before all module definitions.</p>

<h2>
<a name="formula-language" class="anchor" href="#formula-language"><span class="octicon octicon-link"></span></a>Formula language</h2>

<p>There are two types of operators: boolean and modal; the modal operators are divided into parametric and nonparametric.
All the natural binding rules are followed; formulae can be put in parentheses to affect the precedence, as usually.
In what follows f and g are valid formulae.</p>

<h4>
<a name="boolean-operators" class="anchor" href="#boolean-operators"><span class="octicon octicon-link"></span></a>Boolean operators:</h4>

<ul>
<li>f and g</li>
<li>f or g</li>
<li>not f</li>
</ul><h4>
<a name="modal-operators" class="anchor" href="#modal-operators"><span class="octicon octicon-link"></span></a>Modal operators:</h4>

<ul>
<li>#EX(selector; (f))</li>
<li>#AX(selector; (f))</li>
<li>#EG(selector; (f))</li>
<li>#AG(selector; (f))</li>
<li>#EF(selector; (f))</li>
<li>#AF(selector; (f))</li>
<li>#EGom(selector; (f))</li>
<li>#AGom(selector; (f))</li>
<li>#EU(selector; (f), (g))</li>
<li>#AU(selector; (f), (g))</li>
</ul><p>The selector in the modal formulae can be either a set of known actions separated by comma or a variable started with 
$ (dollar symbol), e.g.: </p>

<pre><code> #EG(act1, act2; prop1) and #EG($variable1; prop1);
</code></pre>

<p>or:</p>

<pre><code> #AF(act1, act2; (prop1 and #AG($var; fail)));
</code></pre>

<p>A complete formula should end with semicolon.</p>

<p>The set of actions allowed to be turned off in the synthesised valuations can be limited using an additional clause at the end of the file, below the formula, e.g.:</p>

<pre><code>switches:
left, right, forward;
</code></pre>

<p>The above says that we consider valuations in which left, right
or forward may not be present (they can't all be missing simultaneously).</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-50414278-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
