{"name":"Spatula","tagline":"Parametric synthesis tool for a branching action temporal logic.","body":"SPATULA alpha\r\n========================================================\r\n\r\nSPATULA is a simple parametric synthesis tool prototype. It takes as an input a network of graphs \r\n(also called mixed transition systems) with labeled nodes and transitions and a parametric \r\nbranching-action logic property to be verified. The output consists of a set of substitutions\r\nunder which the property holds. \r\n\r\nIn the examples/ directory you can find example models and model generators: Peterson's mutual exclusion prootocol with malicious process injected, and toy, scalable example used to measure the tool's efficiency.\r\n\r\nInstallation\r\n------------\r\nIt should be easy on a recent Linux machine, just type 'make'. \r\nThe main dependencies are induced by Fabio Somenzi's CUDD package (here, the CUDD 2.5.0 is used).\r\n\r\n\r\nModel description language\r\n--------------------------\r\n\r\nThe used language is a simple C-like one. A system consists of one or more independent \r\nmodules. A module is defined using the \"module\" keyword, as in:\r\n\r\n    module Single:\r\n      i = 0;\r\n      for i in (0..100) {\r\n        vertex = \"vertex_\" + i;\r\n        bloom(vertex);\r\n      }\r\n\r\n(The above code creates 100 vertices, named \"vertex_n\" where n ranges over [0, 99].\r\nThe range in for loop needs to be literal, without references.)\r\n\r\nAll the used variables need to be defined and initialised. There is no variable\r\nshadowing, so once defined a variable is visible in its scope and all subscopes.\r\nVariables can only take two types, string and integer. Arithmetic operations on \r\nintegers are allowed; strings implement only concatenation. An integer can be added \r\nto string and the result is a string via concatenation. Once a variable has an \r\nassociated value, its type can't be changed.\r\n\r\n    module Variables:\r\n    /* valid statements */\r\n    st = \"a string\";\r\n    st = st + \"_\";  \r\n    st = st + 1001; \r\n    in = 1234;\r\n    nst = st + in;\r\n    inval = in/0; /* causes runtime error */\r\n    \r\n    /* errors */\r\n    st = 123; /* type mismatch */\r\n    in = st; /* type mismatch */\r\n\r\nCore graph-building functionalities are:\r\n\r\n    /* emerges a vertex with vertex_name */\r\n    bloom(vertex_name); \r\n    \r\n    /* labels previously emerged vertex vertex_name with proposition */\r\n    mark_with(vertex_name, proposition); \r\n\r\nNote: if you mark a vertex with \"initial\" label, then it will be an initial node.\r\n\r\n    /* joins first vertex with second one (both need to be bloomed before)\r\n    and labels the transition with trans_label                          */\r\n    join_with(first, last, trans_label);\r\n\r\nThe language supports three types of flow control operations: while, if/else and for.\r\nThe example of \"for\" use is shown above. The remaining operations are as in the following\r\nexample.\r\n\r\n    module Single:\r\n      x = 0; max = 5;\r\n      while(x < max) {\r\n\r\n        current = \"vertex_\" + x; /* current vertex name */\r\n        bloom(current); /* make vertex */\r\n\r\n        if(x >= 1) { /* join previous and current vertex with jump label */\r\n        previous = \"vertex_\" + (x - 1);\r\n        join_with(previous, current, \"jump\"); \r\n        }\r\n\r\n      if(x%2 == 1) /* mark vertices with labels */\r\n        mark_with(current, \"p\");\r\n      else \r\n        mark_with(current, \"q\");\r\n\r\n      x = x + 1;    \r\n     }       \r\n\r\n     /* join last with first */\r\n     first = \"vertex_\" + (max - 1);\r\n     last = \"vertex_\" + 0;\r\n     join_with(first, last, \"return\");\r\n\r\nOnly simple comparisons are allowed in conditions, so use double 'if' in place\r\nof 'and', e.g.:\r\n\r\n     if(i != 2) if(i != 3) mark_with(vec, \"p\");\r\n\r\nFor simple debugging the \"stackdump\" operation can be called to print the current interpreter stack.\r\n\r\nIf you wish to use a disjunctive semantics for parallel composition, put:\r\n\r\n    semantics disjunctive;\r\n\r\nbefore all module definitions.\r\n\r\nFormula language\r\n----------------\r\n\r\nThere are two types of operators: boolean and modal; the modal operators are divided into parametric and nonparametric.\r\nAll the natural binding rules are followed; formulae can be put in parentheses to affect the precedence, as usually.\r\nIn what follows f and g are valid formulae.\r\n\r\n#### Boolean operators:\r\n * f and g\r\n * f or g\r\n * not f\r\n\r\n#### Modal operators:\r\n * #EX(selector; (f))\r\n * #AX(selector; (f))\r\n * #EG(selector; (f))\r\n * #AG(selector; (f))\r\n * #EF(selector; (f))\r\n * #AF(selector; (f))\r\n * #EGom(selector; (f))\r\n * #AGom(selector; (f))\r\n * #EU(selector; (f), (g))\r\n * #AU(selector; (f), (g))\r\n\r\nThe selector in the modal formulae can be either a set of known actions separated by comma or a variable started with \r\n$ (dollar symbol), e.g.: \r\n\r\n     #EG(act1, act2; prop1) and #EG($variable1; prop1);\r\n\r\nor:\r\n\r\n     #AF(act1, act2; (prop1 and #AG($var; fail)));\r\n     \r\nA complete formula should end with semicolon.\r\n\r\nThe set of actions allowed to be turned off in the synthesised valuations can be limited using an additional clause at the end of the file, below the formula, e.g.:\r\n\r\n    switches:\r\n    left, right, forward;\r\n\r\nThe above says that we consider valuations in which left, right\r\nor forward may not be present (they can't all be missing simultaneously).\r\n\r\n\r\n","google":"UA-50414278-1","note":"Don't delete this file! It's used internally to help with page regeneration."}